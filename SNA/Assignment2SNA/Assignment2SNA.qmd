---
title: "Assignment 2 SNA"
author: "Marc Sparhuber"
format: pdf
editor: source
execute:
  warning: false
  echo: false
toc: true
header-includes:
      - \usepackage{float}
      - \floatplacement{table}{H}
---

## Task 1 & Packages

Formulate theoretical arguments and expectations about interstate relations. Think in network terms. Select the appropriate part of the data for analysis.

> 

```{r}
library(tidyverse)
library(igraph)

data <- read_csv("C:/Users/User/Desktop/Labs and Assignments Winter early 24/CSS_Labs_early_24/SNA/Assignment2SNA/terr-changes-v6/tc2018.csv")
#data <- read_csv("C:/Users/marcs/Desktop/Labs/CSS_Labs_early_24/SNA/Assignment2SNA/terr-changes-v6/tc2018.csv")
country_codes <- read.csv("C:/Users/User/Desktop/Labs and Assignments Winter early 24/CSS_Labs_early_24/SNA/Assignment2SNA/COW-country-codes.csv")
#country_codes <- read.csv("C:/Users/marcs/Desktop/Labs/CSS_Labs_early_24/SNA/Assignment2SNA/COW-country-codes.csv")

country_codes_gain <- country_codes |> rename(gainer = CCode) |> select(-StateAbb) |> distinct()
country_codes_entity <- country_codes |> rename(entity = CCode) |> select(-StateAbb) |> distinct()
country_codes_loser <- country_codes |> rename(loser = CCode) |> select(-StateAbb) |> distinct()

data$entity <- as.numeric(data$entity)

data <- data |> left_join(country_codes_gain, join_by(gainer)) |> select(-gainer) |> rename(gainer = StateNme) |>
  left_join(country_codes_entity, join_by(entity)) |> select(-entity) |> rename(entity = StateNme) |>
  left_join(country_codes_loser, join_by(loser)) |> select(-loser) |> rename(loser = StateNme) |> 
  relocate(any_of(c("gainer", "loser", "entity")), .before = year) |> select(-version) |> drop_na(any_of(c("gainer", "loser")))

data$entry[data$entry == -9] <- NA

# North_America <- c("United States of America", "Canada", "Bahamas", "Cuba", "Haiti", "Dominican Republic", "Jamaica", "Trinidad and Tobago", "Barbados", "Dominica", "Grenada", "St. Lucia", "St. Vincent and the Grenadines", "Antigua & Barbuda", "St. Kitts and Nevis", "Mexico", "Belize", "Guatemala", "Honduras", "El Salvador", "Nicaragua", "Costa Rica", "Panama")
# 
# South_America <- c("Colombia", "Venezuela", "Guyana", "Suriname", "Ecuador", "Peru", "Brazil", "Bolivia", "Paraguay", "Chile", "Argentina", "Uruguay")
# 
# Europe <- c("United Kingdom", "Ireland", "Netherlands", "Belgium", "Luxembourg", "France", "Monaco", "Liechtenstein", "Switzerland", "Spain", "Andorra", "Portugal", "Hanover", "Bavaria", "Germany", "German Federal Republic", "German Democratic Republic", "Baden", "Saxony", "Wuerttemburg", "Hesse Electoral", "Hesse Grand Ducal", "Mecklenburg Schwerin", "Poland", "Austria-Hungary", "Austria", "Hungary", "Czechoslovakia", "Czech Republic", "Slovakia", "Italy", "Papal States", "Two Sicilies", "San Marino", "Modena", "Parma", "Tuscany", "Malta", "Albania", "Montenegro", "Macedonia", "Croatia", "Yugoslavia", "Bosnia and Herzegovina", "Kosovo", "Slovenia", "Greece", "Cyprus", "Bulgaria", "Moldova", "Romania", "Russia", "Estonia", "Latvia", "Lithuania", "Ukraine", "Belarus", "Armenia", "Georgia", "Azerbaijan", "Finland", "Sweden", "Norway", "Denmark", "Iceland")
# 
# Africa <- c("Cape Verde", "Sao Tome and Principe", "Guinea-Bissau", "Equatorial Guinea", "Gambia", "Mali", "Senegal", "Benin", "Mauritania", "Niger", "Ivory Coast", "Guinea", "Burkina Faso", "Liberia", "Sierra Leone", "Ghana", "Togo", "Cameroon", "Nigeria", "Gabon", "Central African Republic", "Chad", "Congo", "Democratic Republic of the Congo", "Uganda", "Kenya", "Tanzania", "Zanzibar", "Burundi", "Rwanda", "Somalia", "Djibouti", "Ethiopia", "Eritrea", "Angola", "Mozambique", "Zambia", "Zimbabwe", "Malawi", "South Africa", "Namibia", "Lesotho", "Botswana", "Swaziland", "Madagascar", "Comoros", "Mauritius", "Seychelles", "Morocco", "Algeria", "Tunisia", "Libya", "Sudan", "South Sudan", "Egypt")
# 
# Asia <- c("Turkmenistan", "Tajikistan", "Kyrgyzstan", "Uzbekistan", "Kazakhstan", "China", "Mongolia", "Taiwan", "Korea", "North Korea", "South Korea", "Japan", "India", "Bhutan", "Pakistan", "Bangladesh", "Myanmar", "Sri Lanka", "Maldives", "Nepal", "Thailand", "Cambodia", "Laos", "Vietnam", "Republic of Vietnam", "Malaysia", "Singapore", "Brunei", "Philippines", "Indonesia", "East Timor")
# 
# Middle_East <- c("Iran", "Turkey", "Iraq", "Syria", "Lebanon", "Jordan", "Israel", "Saudi Arabia", "Yemen Arab Republic", "Yemen", "Yemen People's Republic", "Kuwait", "Bahrain", "Qatar", "United Arab Emirates", "Oman", "Afghanistan")
# 
# Oceania <- c("Australia", "Papua New Guinea", "New Zealand", "Vanuatu", "Solomon Islands", "Kiribati", "Tuvalu", "Fiji", "Tonga", "Nauru", "Marshall Islands", "Palau", "Federated States of Micronesia", "Samoa")
# 
# Southeast_Asia <- c("Thailand", "Cambodia", "Laos", "Vietnam", "Republic of Vietnam", "Malaysia", "Singapore", "Brunei", "Philippines", "Indonesia", "East Timor", "Myanmar")

Island_States <- c(
    "Bahamas", "Cuba", "Haiti", "Dominican Republic", "Jamaica",
    "Trinidad and Tobago", "Barbados", "Dominica", "Grenada", "St. Lucia",
    "St. Vincent and the Grenadines", "Antigua & Barbuda", "St. Kitts and Nevis",
    "Sao Tome and Principe",
    "Cape Verde", "Comoros", "Mauritius", "Seychelles", "Maldives",
      "Sri Lanka", "Indonesia", "East Timor", "Papua New Guinea",
    "New Zealand", "Vanuatu", "Solomon Islands", "Kiribati", "Tuvalu",
    "Fiji", "Tonga", "Nauru", "Marshall Islands", "Palau",
    "Federated States of Micronesia", "Samoa", "Bahrain", "Brunei", "Cyprus", "Iceland", "Ireland", "Japan",
    "Madagascar", "Malta", "Philippines", "Singapore", "Taiwan", "Zanzibar"
)

data <- data |> 
  rowwise() |> 
  mutate(
    # contains_oceanic = if_any(c(gainer, entity, loser), ~. %in% Oceania),
    # contains_africa = if_any(c(gainer, entity, loser), ~. %in% Africa),
    # contains_middle_east = if_any(c(gainer, entity, loser), ~. %in% Middle_East),
    # contains_asia = if_any(c(gainer, entity, loser), ~. %in% Asia),
    # contains_south_east_asia = if_any(c(gainer, entity, loser), ~. %in% Southeast_Asia),
    # contains_europe = if_any(c(gainer, entity, loser), ~. %in% Europe),
    # contains_south_america = if_any(c(gainer, entity, loser), ~. %in% South_America),
    # contains_north_america = if_any(c(gainer, entity, loser), ~. %in% North_America),
    island_state = if_any(c(gainer, entity, loser), ~. %in% Island_States)
  ) |> 
  ungroup()
```

```{r}
data_graph <- data |> filter(island_state == T) |> mutate(
  entity = if_else(entity == gainer, " ", entity)
)

graph <- igraph::graph_from_data_frame(data_graph, directed = TRUE, vertices = NULL)
```


## Task 2

On the selected data, make a table that contains descriptive network statistics for the network and for key node-level variables. Please mention the historical period covered, the nature of tie(s), the number of nodes and ties, average degree, density, the standard deviation of degrees (or outdegrees and of indegrees if network is directed), and average path length. Identify the number of isolates if there are any. Please check if the network is a single component. Which node has the highest degree, and which has the highest betweenness centrality? What do these measures represent in terms of the specific type of relations and data you have selected?

```{r}

# calucate density
density <- edge_density(graph)

# due to this being an undirected network, it makes no sense to caluclate in/outdegree. Instead, only the degrees are caluclated.
degrees <- igraph::degree(graph, mode='all')
degrees_in <- igraph::degree(graph, mode='in')
degrees_out <- igraph::degree(graph, mode='out')

mean_degrees <- mean(degrees)
mean_degrees_in <- mean(degrees_in)
mean_degrees_out <- mean(degrees_out)

median_degrees <- median(degrees)
median_degrees_in <- median(degrees_in)
median_degrees_out <- median(degrees_out)

# calucate standard deviation of degrees
sd_degrees <- sd(degrees)
sd_degrees_in <- sd(degrees_in)
sd_degrees_out <- sd(degrees_out)

# calucate reciprocity
reciprocity <- reciprocity(graph)

# calucate transitivity
transitivity <- transitivity(graph)

# average path length
av_p_length <- mean_distance(graph)

# number of isolates
# there are no isolates due to the nature of this data set

# how many components

n_components <- components(graph)$no

#which node highest degree
#
# as data frame with order and slice to get highest value

# ecount(m2) # there are 39 ties
# E(m2)
# (edge_btw_1 <- edge_betweenness(m2))
# max(edge_btw_1)
# which(edge_btw_1 == max(edge_btw_1))
# delete.edges(m2,19)

degrees
# uk with 32

#which node highest betweenness

betweenness <- betweenness(graph)
betweenness
# uk with 174

```


## Task 3 

Visualize the network. Vary degree color and size according to key node attributes. Try to pick a node attribute that relates to an important characteristic (e.g., power, GDP per capita).

```{r}
#maybe add independence here or something interesting
## figure out a way to deal with entity and loser the same

# find way to deal with several rows but differing "entry"

# size according to pop or area

independence_pull <- data_graph |> filter(indep == 1) |> pull(gainer)
conflict_gain_pull <- data_graph |> filter(conflict == 1) |> pull(gainer)
conflict_lose_pull <- data_graph |> filter(conflict == 1) |> pull(loser)
conflict_ent_pull <- data_graph |> filter(conflict == 1) |> pull(entity)

conflict_pull <- union(conflict_gain_pull,conflict_lose_pull) |> union(conflict_ent_pull) |> head(-2)

V(graph)$independence <- if_else(V(graph)$name %in% independence_pull, TRUE, FALSE)
V(graph)$conflict <- if_else(V(graph)$name %in% conflict_pull, TRUE, FALSE)

#ERROR HERE --> NEEDS SPECIFIC VALUE FOR EACH NODE, NOT EACH ROW

plot.igraph(graph,
            edge.label = data_graph$entity,
vertex.size = 4,
vertex.color = ifelse(V(graph)$independence == TRUE,"Green", "Red"),
vertex.shape = ifelse(V(graph)$conflict == TRUE ,'square','circle'),
edge.color = 'grey20',
edge.arrow.size = .2, 
main = 'Gainers and losers of territory with island states involved 1816 - 2015')
```

## Task 4

Implement and compare the results (community compositions, their size) of TWO different community detection algorithms to find communities (e.g., Girvan-Newman, Louvain, walktrap, cohesive blocks, Leiden). Please take into account that most of these methods can use undirected graphs only, others (such as Girvan-Newman) might work with weighted graphs. Before carrying out this task, simplify the data if necessary. Create a plot where nodes are either colored based on detected community membership, or you circulate the groups with some color in the background.

```{r}
#edge.betweenness.community
eb_graph <- cluster_edge_betweenness(graph, directed = T)
plot(eb_graph, graph, edge.label = data_graph$entity,
vertex.size = 4,
vertex.color = if_else(data_graph$entry == 1,"Green", "Red"),
edge.color = 'grey20',
edge.arrow.size = .3, 
main = 'Gainers and losers of territory with island states involved 1816 - 2015')

#dendro
eb_dendro <- plot_dendrogram(eb_graph, mode="phylo", colbar = palette(), use.edge.length = TRUE)
eb_dendro
#modularity
modularity(graph, eb_graph$membership)


#INFOMAP
info_graph <- cluster_infomap(graph, modularity = TRUE, nb.trials = 100)
plot(info_graph, graph, edge.label = data_graph$entity,
vertex.size = 4,
vertex.color = ifelse(data_graph$entry == 1,"Green", "Red"),
edge.color = 'grey20',
edge.arrow.size = .3, 
main = 'Gainers and losers of territory with island states involved 1816 - 2015')

#dendro
info_dendro <- as.dendrogram(info_graph)
#modularity
modularity(graph, info_graph$membership)

```

## Task 5

Make meaningful comparisons between the results of community detection algorithms. Summarize the differences and similarities and try to explain these. Please refer to the relevant literature describing the logic of these algorithms if necessary. 

```{r}
compare(info_graph,eb_graph)
```


