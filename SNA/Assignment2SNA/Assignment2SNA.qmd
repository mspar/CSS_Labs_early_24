---
title: "Assignment 2 SNA - Island State Communities"
author: "Marc Sparhuber"
format: pdf
editor: source
execute:
  warning: false
  echo: false
toc: true
header-includes:
      - \usepackage{float}
      - \floatplacement{table}{H}
---

\newpage 

## Task 1

Formulate theoretical arguments and expectations about interstate relations. Think in network terms. Select the appropriate part of the data for analysis.

> In the following, a subset of the territorial change data set will be analyzed. The terriotrial exchange data set contains all territorial changes involving at least one nation-state for the period 1816-2015. It captures the country which gained, lost and (if applicable), a territorial entity exchanged. Furthermore, other notable variables such as the area, population of the gained/lost territory are captured, as well as dummy variables indicating whether independence was gained, military conflict was involved, and what kind of territorial exchange took place are recorded.

> The following subset contains only those entries in the data set in which an island state is recorded as either the gainer, loser or exchanged territory of a territorial change. It is hypothesized that Island states which are bigger in area are more fought for and thus have more ties indicating military conflict. Within a meso context looking at communities within these countries, it is expected that although the communities will to a large extent reproduce the colonia history that many island states endured, that islands which are bigger (and thus, more valuable) had a larger number of territoral exchanges and serve as the nodes between or within more than one community, as they attracted the attention of not just one colonial power. It has to be noted that the ability to test this hypothesis is limited by the fact that islands which are still part of their past colonial power's state are not part of this data set (e.g., Dutch Carribbean).

```{r}
library(tidyverse)
library(igraph)
library(knitr)
library(kableExtra)
library(ape)

data <- read_csv("C:/Users/User/Desktop/Labs and Assignments Winter early 24/CSS_Labs_early_24/SNA/Assignment2SNA/terr-changes-v6/tc2018.csv")
#data <- read_csv("C:/Users/marcs/Desktop/Labs/CSS_Labs_early_24/SNA/Assignment2SNA/terr-changes-v6/tc2018.csv")
country_codes <- read.csv("C:/Users/User/Desktop/Labs and Assignments Winter early 24/CSS_Labs_early_24/SNA/Assignment2SNA/COW-country-codes.csv")
#country_codes <- read.csv("C:/Users/marcs/Desktop/Labs/CSS_Labs_early_24/SNA/Assignment2SNA/COW-country-codes.csv")

country_codes_gain <- country_codes |> rename(gainer = CCode) |> select(-StateAbb) |> distinct()
country_codes_entity <- country_codes |> rename(entity = CCode) |> select(-StateAbb) |> distinct()
country_codes_loser <- country_codes |> rename(loser = CCode) |> select(-StateAbb) |> distinct()

data$entity <- as.numeric(data$entity)
data$area <- as.numeric(data$area)

data <- data |> left_join(country_codes_gain, join_by(gainer)) |> select(-gainer) |> rename(gainer = StateNme) |>
  left_join(country_codes_entity, join_by(entity)) |> select(-entity) |> rename(entity = StateNme) |>
  left_join(country_codes_loser, join_by(loser)) |> select(-loser) |> rename(loser = StateNme) |> 
  relocate(any_of(c("gainer", "loser", "entity")), .before = year) |> select(-version) |> drop_na(any_of(c("gainer", "loser")))

data$entry[data$entry == -9] <- NA

# North_America <- c("United States of America", "Canada", "Bahamas", "Cuba", "Haiti", "Dominican Republic", "Jamaica", "Trinidad and Tobago", "Barbados", "Dominica", "Grenada", "St. Lucia", "St. Vincent and the Grenadines", "Antigua & Barbuda", "St. Kitts and Nevis", "Mexico", "Belize", "Guatemala", "Honduras", "El Salvador", "Nicaragua", "Costa Rica", "Panama")
# 
# South_America <- c("Colombia", "Venezuela", "Guyana", "Suriname", "Ecuador", "Peru", "Brazil", "Bolivia", "Paraguay", "Chile", "Argentina", "Uruguay")
# 
# Europe <- c("United Kingdom", "Ireland", "Netherlands", "Belgium", "Luxembourg", "France", "Monaco", "Liechtenstein", "Switzerland", "Spain", "Andorra", "Portugal", "Hanover", "Bavaria", "Germany", "German Federal Republic", "German Democratic Republic", "Baden", "Saxony", "Wuerttemburg", "Hesse Electoral", "Hesse Grand Ducal", "Mecklenburg Schwerin", "Poland", "Austria-Hungary", "Austria", "Hungary", "Czechoslovakia", "Czech Republic", "Slovakia", "Italy", "Papal States", "Two Sicilies", "San Marino", "Modena", "Parma", "Tuscany", "Malta", "Albania", "Montenegro", "Macedonia", "Croatia", "Yugoslavia", "Bosnia and Herzegovina", "Kosovo", "Slovenia", "Greece", "Cyprus", "Bulgaria", "Moldova", "Romania", "Russia", "Estonia", "Latvia", "Lithuania", "Ukraine", "Belarus", "Armenia", "Georgia", "Azerbaijan", "Finland", "Sweden", "Norway", "Denmark", "Iceland")
# 
# Africa <- c("Cape Verde", "Sao Tome and Principe", "Guinea-Bissau", "Equatorial Guinea", "Gambia", "Mali", "Senegal", "Benin", "Mauritania", "Niger", "Ivory Coast", "Guinea", "Burkina Faso", "Liberia", "Sierra Leone", "Ghana", "Togo", "Cameroon", "Nigeria", "Gabon", "Central African Republic", "Chad", "Congo", "Democratic Republic of the Congo", "Uganda", "Kenya", "Tanzania", "Zanzibar", "Burundi", "Rwanda", "Somalia", "Djibouti", "Ethiopia", "Eritrea", "Angola", "Mozambique", "Zambia", "Zimbabwe", "Malawi", "South Africa", "Namibia", "Lesotho", "Botswana", "Swaziland", "Madagascar", "Comoros", "Mauritius", "Seychelles", "Morocco", "Algeria", "Tunisia", "Libya", "Sudan", "South Sudan", "Egypt")
# 
# Asia <- c("Turkmenistan", "Tajikistan", "Kyrgyzstan", "Uzbekistan", "Kazakhstan", "China", "Mongolia", "Taiwan", "Korea", "North Korea", "South Korea", "Japan", "India", "Bhutan", "Pakistan", "Bangladesh", "Myanmar", "Sri Lanka", "Maldives", "Nepal", "Thailand", "Cambodia", "Laos", "Vietnam", "Republic of Vietnam", "Malaysia", "Singapore", "Brunei", "Philippines", "Indonesia", "East Timor")
# 
# Middle_East <- c("Iran", "Turkey", "Iraq", "Syria", "Lebanon", "Jordan", "Israel", "Saudi Arabia", "Yemen Arab Republic", "Yemen", "Yemen People's Republic", "Kuwait", "Bahrain", "Qatar", "United Arab Emirates", "Oman", "Afghanistan")
# 
# Oceania <- c("Australia", "Papua New Guinea", "New Zealand", "Vanuatu", "Solomon Islands", "Kiribati", "Tuvalu", "Fiji", "Tonga", "Nauru", "Marshall Islands", "Palau", "Federated States of Micronesia", "Samoa")
# 
# Southeast_Asia <- c("Thailand", "Cambodia", "Laos", "Vietnam", "Republic of Vietnam", "Malaysia", "Singapore", "Brunei", "Philippines", "Indonesia", "East Timor", "Myanmar")

Island_States <- c(
    "Bahamas", "Cuba", "Haiti", "Dominican Republic", "Jamaica",
    "Trinidad and Tobago", "Barbados", "Dominica", "Grenada", "St. Lucia",
    "St. Vincent and the Grenadines", "Antigua & Barbuda", "St. Kitts and Nevis",
    "Sao Tome and Principe", "Cape Verde", "Comoros", "Mauritius", "Seychelles", "Maldives",
      "Sri Lanka", "Indonesia", "East Timor", "Papua New Guinea",
    "New Zealand", "Vanuatu", "Solomon Islands", "Kiribati", "Tuvalu",
    "Fiji", "Tonga", "Nauru", "Marshall Islands", "Palau",
    "Federated States of Micronesia", "Samoa", "Bahrain", "Brunei", "Cyprus", "Iceland", "Ireland",       "Japan", "Madagascar", "Malta", "Philippines", "Singapore", "Taiwan", "Zanzibar"
)

data <- data |> 
  rowwise() |> 
  mutate(
    # contains_oceanic = if_any(c(gainer, entity, loser), ~. %in% Oceania),
    # contains_africa = if_any(c(gainer, entity, loser), ~. %in% Africa),
    # contains_middle_east = if_any(c(gainer, entity, loser), ~. %in% Middle_East),
    # contains_asia = if_any(c(gainer, entity, loser), ~. %in% Asia),
    # contains_south_east_asia = if_any(c(gainer, entity, loser), ~. %in% Southeast_Asia),
    # contains_europe = if_any(c(gainer, entity, loser), ~. %in% Europe),
    # contains_south_america = if_any(c(gainer, entity, loser), ~. %in% South_America),
    # contains_north_america = if_any(c(gainer, entity, loser), ~. %in% North_America),
    island_state = if_any(c(gainer, entity, loser), ~. %in% Island_States)
  ) |> 
  ungroup()

data <- data |> mutate(area_log = log(area))
```

```{r}
data_graph <- data |> filter(island_state == T) |> mutate(
  entity = if_else(entity == gainer, " ", entity)
)

graph <- igraph::graph_from_data_frame(data_graph, directed = TRUE, vertices = NULL)


independence_pull <- data_graph |> filter(indep == 1) |> pull(gainer)
conflict_gain_pull <- data_graph |> filter(conflict == 1) |> pull(gainer)
conflict_lose_pull <- data_graph |> filter(conflict == 1) |> pull(loser)
conflict_ent_pull <- data_graph |> filter(conflict == 1) |> pull(entity)


data_graph <- data_graph |> summarise(area_gained = sum(area), .by = "gainer") |> left_join(x = data_graph,y = _, by = join_by(gainer))

pull_area <- data_graph |> group_by(gainer) |> distinct(area_gained) |> rbind(data.frame(gainer = c("Korea", "Denmark", "India"), area_gained = 0000000000000000.1)) |> ungroup()

conflict_pull <- union(conflict_gain_pull,conflict_lose_pull) |> union(conflict_ent_pull) |> head(-2)

V(graph)$independence <- if_else(V(graph)$name %in% independence_pull, TRUE, FALSE)
V(graph)$conflict <- if_else(V(graph)$name %in% conflict_pull, TRUE, FALSE)
V(graph)$log_gained <- log(pull_area$area_gained)
```


## Task 2

On the selected data, make a table that contains descriptive network statistics for the network and for key node-level variables. Please mention the historical period covered, the nature of tie(s), the number of nodes and ties, average degree, density, the standard deviation of degrees (or outdegrees and of indegrees if network is directed), and average path length. Identify the number of isolates if there are any. Please check if the network is a single component. Which node has the highest degree, and which has the highest betweenness centrality? What do these measures represent in terms of the specific type of relations and data you have selected?

> The subset data contains entries ranging from 1819 to 1994. Due to nature of this dataset, all ties ties are directed. Any dyads in which either the gaining or losing side were not clearly indicated, were removed, thereby reducing the number of all isolates to 0. In total, this leaves 62 nodes and 107 ties within 3 components, the largest of which contains most nodes, at 56 nodes. The single node with the highest betweenness and degree centrality is the United Kingdom, with 473 and 41, respectively. This foreshadows a highly hierarchical graph with the UK at its core, backed up by its seafaring prowess in previous centuries leading to the colonialization of many island territories (and their later cession).

```{r}
#| fig-align: center

# calucate density
density <- edge_density(graph)

# due to this being an undirected network, it makes no sense to calculate in/outdegree. Instead, only the degrees are caluclated.
degrees <- igraph::degree(graph, mode='all')
degrees_in <- igraph::degree(graph, mode='in')
degrees_out <- igraph::degree(graph, mode='out')

mean_degrees <- mean(degrees)
mean_degrees_in <- mean(degrees_in)
mean_degrees_out <- mean(degrees_out)

median_degrees <- median(degrees)
median_degrees_in <- median(degrees_in)
median_degrees_out <- median(degrees_out)

# calucate standard deviation of degrees
sd_degrees <- sd(degrees)
sd_degrees_in <- sd(degrees_in)
sd_degrees_out <- sd(degrees_out)

# calucate reciprocity
reciprocity <- reciprocity(graph)

# calucate transitivity
transitivity <- transitivity(graph)

# average path length
av_p_length <- mean_distance(graph)

# number of isolates
# there are no isolates due to the nature of this data set

# how many components
components <- components(graph)
n_components <- components$no

#which node highest degree
#
# as data frame with order and slice to get highest value

highest_degrees <- degrees |> as.data.frame() |> arrange(desc(degrees)) |> slice(1)
# uk with 41

#which node highest betweenness

betweenness <- betweenness(graph)

V(graph)$betweenness <- betweenness

highest_betweenness <- betweenness |> as.data.frame() |> arrange(desc(betweenness)) |> slice(1)
# uk with 473

tibble(
  `Measure/Variable` = c("Degrees","Outdegrees","Indegrees", "Path length", "Density","Reciprocity","Transitivity","Area gained"),
  `Mean/Value` = c(mean_degrees, mean_degrees_out, mean_degrees_in, av_p_length, density, reciprocity, transitivity, mean(pull_area$area_gained)),
  `Standard Deviation` = c(sd_degrees, sd_degrees_out, sd_degrees_in, NA_integer_, NA_integer_,NA_integer_,NA_integer_,sd(pull_area$area_gained)),
  Median = c(median_degrees, median_degrees_out, median_degrees_in, NA_integer_, NA_integer_, NA_integer_, NA_integer_,median(pull_area$area_gained))
) |> kable(caption = "Network Descriptives")
```

> Table 1 shows network descriptives and the distribution of gained area in the observed dyads. The large SD and the vastly differing Median and mean indicate the strongly varying sizes in territory gained by regulating the size of node in later visualizations. Meanwhile, the low degree-related measures, specifically the median, indicate that this graph will contain few highly central nodes, which is to be expected, as seafaring and colonizing nations such as the UK, Netherlands and Spain are expected to have the highest centrality with most island states only having a single tie to their previous colonizers. The low density of ~0.03 shows that this is a rather sparse network, with many potential but unrealized ties. Regarding reciprocity, 35% of ties are reciprocated. This is larger than anticipated, as most island state ties are expected to only contain the "freeing" tie, rather than the "colonizing" tie, which in many cases falls outside the time frame of this data set. Without interpreting the rest of the measures, these descriptives indicate that many of the island states are unlikely to have ties with one another and largely have "one-way" ties with their previous colonizers that serve as highly central hubs.

## Task 3 

Visualize the network. Vary degree color and size according to key node attributes. Try to pick a node attribute that relates to an important characteristic (e.g., power, GDP per capita).

```{r}
#| fig-width: 10
#| fig-height: 10

plot.igraph(graph,
vertex.size = 4+0.4*V(graph)$log_gained,
vertex.color = ifelse(V(graph)$independence == TRUE,"Green", "Red"),
edge.color = ifelse(data_graph$conflict == 1 ,'Orange','Blue'),
edge.arrow.size = .3,
main = 'Gainers and losers of territory with island states involved 1819 - 1994')
```

> In this network visualization, node size scales with the log of total territory gained from corresponding loser nodes, which the color indicates whether this state has obtained independence, with green indicating independence, and the tie color orange indicating whether military conflict was involved in the territory exchange indicated by the tie. Importantly, the direction of the arrow indicates the gaining of territory, so that many green-coloured small island states pointing toward the UK represents them gaining their independence - most frequently without military intervention. At first glance, excluding the two smaller components, the main component seems to be roughly divisible into two to four communities (depending on seed), each centering around a colonizing power with island states contested by more than one colonizing power often serving connectors between the modules.

## Task 4

Implement and compare the results (community compositions, their size) of TWO different community detection algorithms to find communities (e.g., Girvan-Newman, Louvain, walktrap, cohesive blocks, Leiden). Please take into account that most of these methods can use undirected graphs only, others (such as Girvan-Newman) might work with weighted graphs. Before carrying out this task, simplify the data if necessary. Create a plot where nodes are either colored based on detected community membership, or you circulate the groups with some color in the background.

> Here, three (because the last one is not listed in the instructions) different community detection algorithms are run and plotted, the last of which is meant specifically for directed networks and the earlier two are accompanied by dendrograms. As many community detection algorithms only allow for undirected networks and/or disallow multiple ties between the same nodes, the necessary versions of the graph are calculated. When comparing the first two plots, a clear distinction can be made: the walktrap algorithms leads to much easier to interpret and cogent results, by attempting to find densly connected subgraphs using random walks, while the edge betweenness algorithm (aka. Girvan-Newman) detects a handful of communities consisting of single nodes, by removing edges from the original graph with the still connected nodes being identified as communities. In this case, the prior leads to much clearer interpretability, while the latter seemingly "overdetects" communities. The third algorithm run is called Infomap and is able to take into account directed ties. While this leads to improved results compared to the Girvan-Newman algorithm, there are still some single country communities that admittedly make sense (as these tend to be more central than others, e.g., Zanzibar), yet do not compare to the results of the walktrap algorithm. The dendrograms show the iterative assimilation of countries into their respective communities by the first two algorithms.  

```{r}
#| fig-width: 10
#| fig-height: 10

# as undirected
graph_undi <- as.undirected(graph, mode='collapse')

walky <- cluster_walktrap(graph_undi, steps = 100)
plot(walky, graph_undi,
     vertex.size = 4+0.5*V(graph)$log_gained,
vertex.color = ifelse(V(graph)$independence == TRUE,"Green", "Red"),
edge.color = ifelse(data_graph$conflict == 1 ,'Orange','Blue'),
edge.arrow.size = .2, 
main = 'Territory change in island states 1816 - 2015: Walktrap')

plot_dendrogram(walky, mode="phylo", colbar = palette(), use.edge.length = TRUE, main = "Dendrogram for communities detected with Walktrap algorithm")
```

```{r}
#| fig-width: 10
#| fig-height: 10

#edge.betweenness.community
eb_graph <- cluster_edge_betweenness(graph, directed = T)
plot(eb_graph, graph, vertex.size = 4+0.5*V(graph)$log_gained,
vertex.color = ifelse(V(graph)$independence == TRUE,"Green", "Red"),
edge.color = ifelse(data_graph$conflict == 1 ,'Orange','Blue'),
edge.arrow.size = .2, 
main = 'Territory change in island states 1816 - 2015: Edge Betweenness')

#dendro
plot_dendrogram(eb_graph, mode="phylo", colbar = palette(), use.edge.length = TRUE, main = "Dendrogram for communities detected with Edge Betweenness algorithm")
#modularity
#modularity(graph, eb_graph$membership)
```

```{r}
#| fig-width: 10
#| fig-height: 10

info_graph <- cluster_infomap(graph, modularity = TRUE, nb.trials = 100)

plot(info_graph, graph, vertex.size = 4+0.5*V(graph)$log_gained,
vertex.color = ifelse(V(graph)$independence == TRUE,"Green", "Red"),
edge.color = ifelse(data_graph$conflict == 1 ,'Orange','Blue'),
edge.arrow.size = .2, 
main = 'Territory change in island states 1816 - 2015: Infomap')
```

## Task 5

Make meaningful comparisons between the results of community detection algorithms. Summarize the differences and similarities and try to explain these. Please refer to the relevant literature describing the logic of these algorithms if necessary. 

```{r}
# compare(walky, eb_graph, method = "vi")
# compare(info_graph, eb_graph, method = "vi")
# compare(walky, info_graph, method = "vi")
# 
# modularity(walky)
# modularity(eb_graph)
# modularity(info_graph)
```

> To make meaningful comparisons between community detection strategies past the a visual interpretation, certain measures can be interpreted. One such measure is modularity. It is close to 1 when there are strongly connected communities, while their connections to other communities are rather weak, indicating clear separations between communities. Meanwhile, values between and around 0 and -1 indicate low modularity, meaning that there are few clear cut communities or that the algorithm doesn't work well with the particular network (Clauset & Newman, 2004). All three community detection algorithms used here result in values around 0.5, indicating moderate modularity. Interestingly, the edge betweenness method scores ~0.05 percentage points lower than the other two, which maybe explained by the many one-country communities it detected, thereby decreasing its modularity.

> Another method is the variation of information metric, proposed by Marina Meilă (2005). It measures the amount of information lost and gained in changing from the first provided community structure to the second and can take values from 0 to positive infinity. The values the measure produces here indicate a greater dissimilarity of the walktrap algorithm to the edge betweenness algorithm (0.94), than the Infomap community to the edge betweenness community (0.78) and the walktrap algorithm to the Infomap algorithm (0.71). This intuitively makes sense, as the walktrap algorithm creates the least communities, while the edge betweenness algorithm creates the most. Correspondingly, the resuts of the walktrap algorithm and the Infomap algorithm also do look the most similar when plotted. Notably, these results are the ones produced by just one run and should ideally be averaged across different results of outcomes of community detection algorithms, as they slightly vary from run to run.

> Coming back to the initially posed hypothesis it can be said that there is no indication of it being correct, with the exception being cases where it could explain results (i.e., Indonesia or Japan). This has to do with little theoretical groundwork to justify it (and make it worthwhile investigating) and a lack of data to answer it.
